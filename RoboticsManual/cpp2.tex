%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label[cpp] \sec Nejčastější příkazy C++

\secc Přiřazovací příkaz  
Použijeme, pokud chceme, aby se do proměnné uložila nějaká data. 

Syntaxe: {\tt  datový\_typ název\_proměnné; } 
 
syntaxe vkládání: 
 
{\tt  název\_proměnné = hodnota\_která\_se\_má\_uložit; }

Data do proměnné můžeme vložit rovnou při vytváření proměnných:

 { \tt  datový\_typ název\_proměnné $=$ hodnota};

Příklad: { \tt  uint8\_t b = 5};  Vytvoří se proměnná pojmenovaná { \tt  b} (která je v rozsahu od 0 do 255) a uloží se do ní číslo { \tt  5}. 

{ \tt  int16\_t B;}  Vytvoří se proměnná { \tt  B}. { \tt  B} není to samé jako { \tt  b}, protože jazyk C rozlišuje VELKÁ a malá písmena. 

{ \tt  B $=$ 1024;}  Do proměnné B se uloží hodnota 1024;

\secc{Blok příkazů} 
Pokud chceme někam dát více příkazů, ale můžeme tam dát pouze jeden příkaz, tak je dáme do složených závorek
Příklad: 
 
\hisyntax{C} \begtt 
{
  PŘÍKAZ1;
  PŘÍKAZ2;
  PŘÍKAZ3;
}
\endtt


\label[if] \secc{Podmiňovací příkaz if }

\ii if Použijeme, pokud chceme, aby se program mohl rozhodnout na základě nějaké podmínky. \ii else
 
syntaxe:

\hisyntax{C} \begtt 
if(PODMÍNKA)
  PŘÍKAZ1;
else
  PŘÍKAZ2;
\endtt

Pokud platí { \tt  PODMÍNKA} v kulaté závorce, vykoná se { \tt  PŘÍKAZ1}, pokud neplatí, vykoná se { \tt  PŘÍKAZ2}.
Za { \tt  if} nebo { \tt  else} může být pouze jeden příkaz, pokud jich tam chceme dát více, použijeme blok.
Větev { \tt  else} je nepovinná.

Příklad:
\hisyntax{C} \begtt 
if(a > 5) // Pokud platí, že 
          //proměnná a je větší něž 5, tak se
{
  b = a;  // do proměnné b uloží hodnota, která je v proměnné a
  c = 2;  // do proměnné c se uloží číslo 2.
} // Pokud podmínka neplatí, tak se nevykoná nic.
\endtt

podmínka může být výraz např.: 
\hisyntax{C} \begtt 
a > 5 // podmínka bude platit, 
      // pokud proměnná a je větší než 5
\endtt
podmíněné příkazy lze vnořovat - v bloku příkazů může být další if
Příklad:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PŘÍKAZ1;
  if(PODMÍNKA2)
  {
    PŘÍKAZ2;
  }
  PŘÍKAZ3;
}
else 
{
  PŘÍKAZ4;
}
\endtt

Pokud platí { \tt  PODMÍNKA1} tak se vykoná { \tt  PŘÍKAZ1}, pak se zkontroluje { \tt  PODMÍNKA2}, pokud platí, tak se vykoná { \tt  PŘÍKAZ2}, pokud ne, program pokračuje dál a vykoná { \tt  PŘÍKAZ3}.
V případě, že neplatí ani { \tt  PODMÍNKA1}, tak se blok příkazů přeskočí a vykoná se blok příkazů za { \tt  else}, tj. { \tt  PŘÍKAZ4}.

Je tu možnost také do větve { \tt  else} napsat daší { \tt  if else}, vypadá to takto:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PRÍKAZ1;
}
else
{
  if(PODMÍNKA2)
  {
    PRÍKAZ2;
  }
  else
  {
    PRÍKAZ3;
  }
}
\endtt
Pokud platí { \tt  PODMÍNKA1}, tak se vykoná { \tt  PŘÍKAZ1}, pokud ne, tak se zkontroluje { \tt  PODMÍNKA2}, pokud platí tak se vykoná { \tt  PŘÍKAZ2}, pokud neplatí, tak se vykoná { \tt  PŘÍKAZ3}. Výše zapsaný kód sice bude fungovat, ale není přehledný, a proto z důvodu lepší orientace v kódu zvolíme tento zápis:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PRÍKAZ1;
}
else if(PODMÍNKA2)
{
  PRÍKAZ2;
}
else
{
  PRÍKAZ3;
}
\endtt

\secc{Příkaz několikanásobného větvení }

Pokud by takto zapsaných podmínek bylo moc a vztahovali by se k jedné řídící proměnné lze použít příkaz několikanásobného větvění neboli {\tt switch}. \ii switch Tak například místo zápisu:

\hisyntax{C} \begtt 
if(a == 1)
{
  PŘÍKAZ1;
}
else if(a == 2)
{
  PŘÍKAZ2;
}
else if(a == 3)
{
  PŘÍKAZ3;
}
else if(a == 4)
{
  PŘÍKAZ4;
}
else
{
  PŘÍKAZ5;
}
\endtt
Lze napsat:
\hisyntax{C} \begtt 
switch(a)
{
  case 1:
    PŘÍKAZ1;
    break;
  case 2:
    PŘÍKAZ2;
    break;
  case 3:
    PŘÍKAZ3;
    break;
  case 4:
    PŘÍKAZ4;
    break;
  default:
    PŘÍKAZ5;
    break;
}
\endtt
Čím se to celé zjednodušuje.

\secc{Cyklus for (cyklus řízený proměnou )} 

\ii for Tento cyklu použijeme, pokud předem známe kolikrát se má opakovat určitá operace
Syntaxe:
\hisyntax{C} \begtt 
for(řidící_proměnná; podmínka; zvýšení_nebo_snížení_hodnoty_proměnné )
{
  PŘÍKAZ1;
  PŘÍKAZ2;
}
\endtt

Příklad:
\hisyntax{C} \begtt 
for(uint8_t i=0; i<4; i++)
{
  rozsvit_ledku();
  pockej_sekundu();
  zhasni ledku();
}
\endtt
Co tento kód udělá? Dejme tomu, že máme už předem vytvořené funkce { \tt  rozsvit\_ledku()}, atd... Potom cyklus udělá následující: vytvoří proměnnou { \tt  i} datového typu { \tt  uint8\_t} (celá čísla od { \tt  0} do { \tt  255}), uloží do ní číslo { \tt  0}. Potom zkontroluje podmínku, zda je proměnná { \tt  i} menší než { \tt  4}, pak se provedou příkazy či funkce v těle cyklu, tj. rozsvítí se LED, bude svítit jednu sekundu, a pak zhasne. Pak se provede příkaz { \tt  i++}, ten zvýší hodnotu proměnné o jednu, tj. na číslo { \tt  1}. Potom se kontroluje znovu podmínka, zdali je proměnná { \tt  i} (která má teď hodnotu { \tt  1}) menší než { \tt  4}, atd... Celkem se tělo cyklu vykoná čtyřikrát.

Cyklus { \tt  for} lze použít i bez proměnné, podmínky a zvýšení hodnoty, potom bude probíhat donekonečna.
Příklad:
{ \tt  for(;;)}
\hisyntax{C} \begtt 
{
  rozsvit_ledku();
  pockej_sekundu();
  zhasni ledku();
}
\endtt 
Tento cyklus bude dělat to samé, co předchozí, s tím rozdílem, že to bude dělat donekonečna a nebude se ptát na podmínku. 

Použití v programu pro robota: Nekonečný cyklus, ve kterém se kontrolují podmínky, zda je na čáře, zda je před ním soupeř, zda má udělat to či ono.


\secc{Cyklus while (cyklus s podmínkou na začátku )} 

\ii while Použijeme, pokud nebudeme vědět kolikrát mají proběhnout příkazy a funkce v těle cyklu.
Syntaxe:

\hisyntax{C} \begtt 
while(podmínka)
{
  PŘÍKAZ1;
  ...
}
\endtt


Příklad:
\hisyntax{C} \begtt 
while(!je_tlacitko_stiskle())
{
  ujed_1_cm();
}
\endtt

Tento cyklus bude stát, dokud nezmáčkneme tlačítko. Vyžaduje mít předem naprogramovanou funkci { \tt  ujed\_1\_cm()} a { \tt  je\_tlacitko\_stiskle()}.

 
%%%%%%%%%%%%%% Napsat cyklus do-while 
  
\sec{Funkce a procedury} 

 Pokud se nám v zdrojovém kódu opakují dokola stejné příkazy, můžeme vytvořit \iid funkce nebo procedury, které potom voláme a které nám usnadní kód.
syntaxe:
\hisyntax{C} \begtt 
datový_typ_který_funkce_vrací název_funkce(datový_typ_parametru1 
parametr1, datový_typ_parametru2 parametr2) 
// Parametry jsou nepovinné
{
  PŘÍKAZ1; // Nepovinné příkazy
  PŘÍKAZ2;
  return HODNOTA_KTEROU_FUNKCE_VRACI; 
  // Za return se napíše výraz, který funkce vrací.
}
\endtt \ii return

Příklad:
\hisyntax{C} \begtt 
// Funkce na sčítání dvou čísel, každé od 0 do 255.
uint16_t umocni(uint8_t zakl, uint8_t exp)
{
  uint16_t vys = 1;
  if(exp > 0)
  {
    for(uint8_t i = 0; i < exp; i++)
    {
      vys = vys * zakl; 
    }
  }
  return vys;
}
\endtt

pokud někde v programu použiji funkci { \tt  secti(10, 2)}, tak výsledkem bude, jako bych napsal { \tt  10*10}, tj. { \tt  100}.
Příklad:
\hisyntax{C} \begtt 
c = umocni(a, b); // Do proměnné c se uloží b-tá mocnina čísla a. 
\endtt

\iid procedura -- je vlastně funkce, jen s tím rozdílem, že procedura má datový typ { \tt  void} \ii void  
a nemá { \tt  return} (tj. nevrací žádnou hodnotu).

Příklad:
\hisyntax{C} \begtt 
void rozsvitLedku()
{
  DDRB |= (1<<PB0); /* Co dělá tento příkaz nemusíte zatím řešit,
   pak se k tomu dostaneme.
   */
}
\endtt

Pokud někde v programu napíšu { \tt  rozsvitLedku()}, tak se rozsvítí LEDka na robotovi.

Celý program v C++ tvoří funkce \iid main -- všechny příkazy, které jsou mezi složenými závorkami, se po zahajení programu postupně vykonají. 

\sec{Knihovny}

\secc{Vlastní knihovny}
Z funkcí a procedur se mohou vytvářet soubory pro usnadnění práce. těmto souborům se říká {\bf knihovny}. \ii knihovna Soubory mají koncovku {\it .h}
Příklad: { \tt  avr/io.h}
{ \tt  moje\_knihovna.h}

Vlastní knihovnu poté mohu vložit direktivou { \tt  \#include}
Příklad:
\hisyntax{C} \begtt 
#include "moje_knihovna.h"
\endtt 

\secc{Použité knihovny}  

Pro práci s čipy budeme potřebovat některé už vytvořené knihovny

Příklad: 

%{ \tt  avr/io.h}  -- pro základní vstup a výstup

%{ \tt  avr/interrupt.h} -- pro práci s přerušením

{ \tt  Arduino.h} -- zavádí příkazy pro práci s čipy ATMega a ESP32

{ \tt  Learningkit.h}  -- pro pohodlnou práci s deskou ALKS

{ \tt  stdint.h}  -- zde je definovány \link[ref:datovy_typ]{\Magenta}{datové typy}\Black   

 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
